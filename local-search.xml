<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++ std::priority_queue优先队列详解</title>
    <link href="/2021/03/14/C-std-priority-queue%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/03/14/C-std-priority-queue%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="std-priority-queue优先队列"><a href="#std-priority-queue优先队列" class="headerlink" title="std::priority_queue优先队列"></a>std::priority_queue优先队列</h1><p>优先队列是一种容器适配器，队列元素要求实现了严格弱排序（Strict Weak Ordering），保证队列顶点（top）元素始终为最大值（最小值）。</p><p>优先队列作为数据结构中堆的一种具体实现，在leetcode算法题中出现频率较高。本文对优先队列的接口和常见用法做一个简单总结。</p><p>优先队列本质上是一种堆，默认最大堆，即每一个父节点的值都比其子节点要大，因此根节点中的元素总是树中的最大值，因此常用于最值的读取。</p><p>在时间复杂度上，优先队列实现单个元素的增删都是O(log n)，而读取队列顶点则为O(1)</p><h1 id="接口原型-🔎"><a href="#接口原型-🔎" class="headerlink" title="接口原型 🔎"></a>接口原型 🔎</h1><p>如下接口定义可以看出，优先队列的定义包含三个元素：</p><ul><li>元素类型T；</li><li>存储元素的基础容器类型，要求为拥有连续内存分布的<a href="https://en.cppreference.com/w/cpp/named_req/SequenceContainer">SequenceContainer</a>， STL中满足的就是std::vector and std::deque两种了；</li><li>元素比较函数Compare， Compare函数主要用于元素比较，实现严格的弱排序，由于排序，优先队列已经不满足“先进先出”的特性了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> =</span> <span class="hljs-built_in">vector</span>&lt;T&gt;,<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compare</span> =</span> less&lt;<span class="hljs-keyword">typename</span> Container::value_type&gt; &gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">priority_queue</span>;</span><br></code></pre></td></tr></table></figure><h2 id="主要成员函数"><a href="#主要成员函数" class="headerlink" title="主要成员函数"></a>主要成员函数</h2><p>所有STL标准库实现的数据结构，都有对应的CRUD（增删改查）接口，形式也基本类似.</p><p><img src="/img/priority_queue_member_function.png" alt="成员函数详解表"></p><h2 id="Comp函数"><a href="#Comp函数" class="headerlink" title="Comp函数"></a><strong>Comp函数</strong></h2><p>comp函数默认为使用仿函数<code>std::less&lt;int&gt;</code>,表示最大堆 ，这里less是降序，但由于优先队列将top指向了队列尾；同理，<code>std::greater&lt;T&gt;</code>,表示最小堆.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compare</span> =</span> less&lt;<span class="hljs-keyword">typename</span> Container::value_type&gt; <br></code></pre></td></tr></table></figure><p>comp函数要求严格弱排序，那么什么是严格弱排序</p><p>维基百科给出了如下定义，简言之就是内置类型会通过<code>!(a &lt; b) &amp;&amp; !( b &lt; a ) </code>来判断ab是否相等，如果判断中携带了<code>=</code>如<code>&gt;=</code>、<code>&lt;=</code>，将导致相等判断逻辑出现错误。</p><blockquote><p>A Strict Weak Ordering is a Binary Predicate that compares two objects, returning true if the first precedes the second. This predicate must satisfy the standard mathematical definition of a strict weak ordering. The precise requirements are stated below, but what they roughly mean is that a Strict Weak Ordering has to behave the way that “less than” behaves: if a is less than b then b is not less than a, if a is less than b and b is less than c then a is less than c, and so on.</p></blockquote><p>另外当元素类型T为自定义类型时，那就需要自定义的comp函数，一般有实现后缀运算<code>()</code>函数 和 重载关系运算符 <code>&lt;</code>、 <code>&gt;</code> 两种方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt; // priority_queue头文件</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt; // 仿函数头文件</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br><span class="hljs-keyword">int</span> x, y; <br>node(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) : x(x), y(y) &#123;&#125; <br>&#125;;<br> <br><span class="hljs-comment">// &lt;操作符用于仿函数std::less</span><br><span class="hljs-comment">// node比较先按照x降序，x相等时，再按照y降序</span><br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (Node a, Node b) <br>&#123; <br>      <span class="hljs-keyword">if</span> (a.x &gt; b.x) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.x == b.x) &#123;<br><span class="hljs-keyword">return</span> a.y &gt; b.y; <span class="hljs-comment">// 严格弱排序</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;      <br>&#125;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">priority_queue</span>&lt;Node, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Node&gt;, <span class="hljs-built_in">std</span>::less&lt;Node&gt;&gt; pq; <span class="hljs-comment">// 大顶堆</span><br><br><span class="hljs-comment">// &gt;操作符用于仿函数std::greater</span><br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &gt; (Node a, Node b)<br>&#123;<br>    <span class="hljs-keyword">return</span> a.x&gt; b.x;<br>&#125;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">priority_queue</span>&lt;Node, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Node&gt;, <span class="hljs-built_in">std</span>::greater&lt;Node&gt;&gt; pq; <span class="hljs-comment">// 小顶堆</span><br><br><span class="hljs-comment">// 自定义后缀操作符</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Node a,Node b)</span></span><br><span class="hljs-function">    </span>&#123;<br>  <span class="hljs-keyword">return</span> a.x &gt; b.x;<br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">priority_queue</span>&lt;Node, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Node&gt;, cmp&gt; pq;<br><br></code></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a href="https://leetcode.com/problems/maximum-average-pass-ratio/">leetcode 1792. Maximum Average Pass Ratio</a></p><p>在如下解答中，可以发现priority_queue的几个关键接口的使用。</p><p>另外算法层面可以看到，通过对优先队列进行增删读元素，使得每次都对最值进行操作，也就保证了每次操作都为最优解。实际上这就是<strong>贪心算法，通过求解每个子问题的最优解，来得到整个问题的最终最优解</strong>。也正因如此，优先队列就常在一些有约束条件下的分配问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// !!整数除法一定先转double, 注意检查括号</span><br>    <span class="hljs-comment">// !!乘法注意溢出，少量的除法误差可以容忍</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cal(xy) ((double)(xy[0] +1) / (xy[1] + 1) - (double)(xy[0]) / (xy[1]))</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">maxAverageRatio</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; classes, <span class="hljs-keyword">int</span> extraStudents)</span> </span>&#123;<br>        <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">int</span>&gt;&gt; qu; <span class="hljs-comment">// 默认最大堆</span><br>        <br>        <span class="hljs-comment">// 入队列，按照分配1个之后的差值，排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; classes.size(); i++) &#123;            <br>            qu.emplace(cal(classes[i]), i); <span class="hljs-comment">// !!优先使用emplace/emplace_back， 比push/push_back更高效</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (extraStudents--) &#123;<br>            <span class="hljs-keyword">auto</span> [diff, i] = qu.top();<br>            qu.pop();<br>            <br>            <br>            <span class="hljs-comment">// 从队列中取出差值最大的一项，即分配给它后结果最大的</span><br>            classes[i][<span class="hljs-number">0</span>]++;<br>            classes[i][<span class="hljs-number">1</span>]++;<br>            <br>            <span class="hljs-comment">// 分配后重新塞回队列</span><br>            qu.push(&#123;cal(classes[i]), i&#125;);<br>        &#125;<br>        <br>        <span class="hljs-keyword">auto</span> maxsum = <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : classes) &#123;           <br>            <span class="hljs-comment">//cout &lt;&lt; cal(c) &lt;&lt; &quot;-&quot; &lt;&lt; c[0] &lt;&lt; &quot;-&quot; &lt;&lt; c[1] &lt;&lt; endl;</span><br>            maxsum += (<span class="hljs-keyword">double</span>)c[<span class="hljs-number">0</span>] / c[<span class="hljs-number">1</span>];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> maxsum / classes.size();<br>    &#125;    <br>&#125;;<br></code></pre></td></tr></table></figure><p>⚠ <strong>Note</strong>: 转载请注明出处</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言中channel的常见用法</title>
    <link href="/2019/02/28/Go%E8%AF%AD%E8%A8%80%E4%B8%ADchannel%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"/>
    <url>/2019/02/28/Go%E8%AF%AD%E8%A8%80%E4%B8%ADchannel%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>K8S</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8S informer机制与使用</title>
    <link href="/2019/02/28/k8s%20informer%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/02/28/k8s%20informer%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>K8S</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes Pod知识图谱</title>
    <link href="/2019/02/28/k8s%20pod%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    <url>/2019/02/28/k8s%20pod%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/k8s-pod.svg" alt="k8s-pod"></p><blockquote><p>参考 <em>《kubernetes 权威指南》</em></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>K8S</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用操作总结</title>
    <link href="/2017/02/28/2020-12-10-git%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2017/02/28/2020-12-10-git%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="批量删除Git分支"><a href="#批量删除Git分支" class="headerlink" title="批量删除Git分支"></a>批量删除Git分支</h2><h3 id="删本地分支"><a href="#删本地分支" class="headerlink" title="删本地分支"></a>删本地分支</h3><p>git branch 输出分支列表， 通过管道过滤出包含关键词 keyname分支名的分支，传递给git branch -D 本地分支强制删除命令中，实现<strong>批量删除包含keyname字符串的本地分支</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">git branch |<span class="hljs-type">grep</span> &#x27;keyname&#x27; | <span class="hljs-type">xargs</span> git branch -D<br></code></pre></td></tr></table></figure><h4 id="删远程分支"><a href="#删远程分支" class="headerlink" title="删远程分支"></a>删远程分支</h4><p>git branch 输出分支列表， 通过管道过滤出包含关键词 keyname分支名的分支，传递给git push origin –delete 远端分支强制删除命令中，实现<strong>批量删除包含keyname字符串的远端分支</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">git branch |<span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;keyname&#x27;</span> | xargs git <span class="hljs-keyword">push</span> origin --<span class="hljs-keyword">delete</span><br></code></pre></td></tr></table></figure><h2 id="误删分支找回"><a href="#误删分支找回" class="headerlink" title="误删分支找回"></a>误删分支找回</h2><p>git reflog查看所有分支的commit记录,根据commit记录创建分支</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">git branch <span class="hljs-keyword">new</span><span class="hljs-type">BranchName</span> HEAD@&#123;**&#125;<br></code></pre></td></tr></table></figure><p>切换到新分支后，push到远端即可恢复远端分支</p><p><img src="/img/findback-branch.png" alt="找回分支"></p><h2 id="Git快捷命令配置（别名）"><a href="#Git快捷命令配置（别名）" class="headerlink" title="Git快捷命令配置（别名）"></a>Git快捷命令配置（别名）</h2><p>git bash窗口中vi /etc/bash.bashrc，在尾部添加如下代码</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">alias</span> gst=<span class="hljs-symbol">&#x27;git</span> status&#x27;<br><span class="hljs-keyword">alias</span> gdiff=<span class="hljs-symbol">&#x27;git</span> diff&#x27;<br><span class="hljs-keyword">alias</span> gadd=<span class="hljs-symbol">&#x27;git</span> add&#x27;<br><span class="hljs-keyword">alias</span> gci=<span class="hljs-symbol">&#x27;git</span> commit -m <span class="hljs-string">&quot;hello world&quot;</span>&#x27;<br><span class="hljs-keyword">alias</span> gthis=<span class="hljs-symbol">&#x27;git</span> rev-parse <span class="hljs-comment">--abbrev-ref HEAD&#x27;</span><br><span class="hljs-keyword">alias</span> gpush=<span class="hljs-symbol">&#x27;git</span> push origin `gthis`&#x27;<br><span class="hljs-keyword">alias</span> gco=<span class="hljs-symbol">&#x27;git</span> checkout&#x27;<br><span class="hljs-keyword">alias</span> gbr=<span class="hljs-symbol">&#x27;git</span> branch&#x27;<br><span class="hljs-keyword">alias</span> gname=<span class="hljs-symbol">&#x27;vi</span> /etc/bash.bashrc&#x27;<br></code></pre></td></tr></table></figure><p>保存后重启bash窗口，生效快捷命令映射</p><p>若保存时，遇到[/etc/bashrc Permission denied，则用管理员权限打开git bash重试即可</p><p><img src="/img/bash-run.png" alt="管理员权限运行bash"></p><h2 id="记录Git用户名密码"><a href="#记录Git用户名密码" class="headerlink" title="记录Git用户名密码"></a>记录Git用户名密码</h2><p>git 默认每次pull等操作时要求输入密码，比较麻烦，可通过如下命令永久保存密码，再输入一次后就无需输入了。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git <span class="hljs-built_in">config</span> credential.helper store<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
